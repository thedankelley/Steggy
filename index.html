<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Steggy ã‚¹ãƒ†ã‚®ãƒ¼</title>
<link rel="icon" href="stegosaurus_icon.png" type="image/png">
<style>
    :root {
        --bg-light: #f5f5f5;
        --bg-dark: #1e1e1e;
        --text-light: #222;
        --text-dark: #eee;
        --primary: #4CAF50;
        --secondary: #ff9800;
    }
    body {
        font-family: sans-serif;
        margin: 0;
        padding: 0;
        background-color: var(--bg-light);
        color: var(--text-light);
        transition: background-color 0.3s, color 0.3s;
    }
    body.dark {
        background-color: var(--bg-dark);
        color: var(--text-dark);
    }
    header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 20px;
        background-color: var(--primary);
        color: white;
    }
    header h1 {
        margin: 0;
        font-size: 1.5em;
    }
    .toggle-mode {
        cursor: pointer;
        font-size: 1.2em;
        user-select: none;
    }
    main {
        padding: 20px;
        max-width: 800px;
        margin: auto;
    }
    label {
        display: block;
        margin-top: 10px;
    }
    input, select, textarea, button {
        margin-top: 5px;
        padding: 5px;
        width: 100%;
        box-sizing: border-box;
    }
    button {
        background-color: var(--secondary);
        border: none;
        color: white;
        cursor: pointer;
        padding: 10px;
        font-size: 1em;
    }
    button:hover {
        opacity: 0.9;
    }
    #advancedSettings {
        display: none;
        border: 1px solid #ccc;
        padding: 10px;
        margin-top: 10px;
    }
    footer {
        text-align: center;
        font-size: 0.8em;
        margin: 20px 0;
    }
    img#outputImage {
        max-width: 100%;
        margin-top: 10px;
        border: 1px solid #ccc;
    }
</style>
</head>
<body>
<header>
    <h1>Steggy ã‚¹ãƒ†ã‚®ãƒ¼</h1>
    <span class="toggle-mode" id="modeToggle">ðŸŒž</span>
</header>
<main>
    <label for="modeSelect">Mode:</label>
    <select id="modeSelect">
        <option value="encrypt">Encrypt</option>
        <option value="decrypt">Decrypt</option>
    </select>

    <label for="inputFile">Input Image:</label>
    <input type="file" id="inputFile" accept="image/*">

    <label for="inputText">Text to hide / file to embed (optional for encrypt):</label>
    <textarea id="inputText" placeholder="Enter text here"></textarea>

    <button id="toggleAdvanced">Advanced Settings</button>
    <div id="advancedSettings">
        <label for="password">AES-GCM Password (optional):</label>
        <input type="password" id="password">

        <label for="pngChunk">Use PNG Chunk Insertion:</label>
        <select id="pngChunk">
            <option value="none">None</option>
            <option value="tEXt">tEXt</option>
            <option value="zTXt">zTXt</option>
        </select>
        <small>Future PGP options will appear here</small>
    </div>

    <button id="processBtn">Process</button>

    <h2>Output:</h2>
    <textarea id="outputText" rows="6" placeholder="Decrypted text appears here"></textarea>
    <img id="outputImage" alt="Decrypted or Encrypted Image">

</main>
<footer>Created by Dan</footer>

<script>
const body = document.body;
const modeToggle = document.getElementById('modeToggle');
const advancedSettings = document.getElementById('advancedSettings');
const toggleAdvanced = document.getElementById('toggleAdvanced');
const inputFile = document.getElementById('inputFile');
const inputText = document.getElementById('inputText');
const outputText = document.getElementById('outputText');
const outputImage = document.getElementById('outputImage');
const processBtn = document.getElementById('processBtn');
const modeSelect = document.getElementById('modeSelect');

let darkMode = false;

modeToggle.addEventListener('click', () => {
    darkMode = !darkMode;
    body.classList.toggle('dark', darkMode);
    modeToggle.textContent = darkMode ? 'ðŸŒœ' : 'ðŸŒž';
    localStorage.setItem('darkMode', darkMode);
});

// Load saved mode
if(localStorage.getItem('darkMode') === 'true') {
    darkMode = true;
    body.classList.add('dark');
    modeToggle.textContent = 'ðŸŒœ';
}

// Toggle advanced settings
toggleAdvanced.addEventListener('click', () => {
    advancedSettings.style.display = advancedSettings.style.display === 'none' ? 'block' : 'none';
});

// Helper: Convert text to Uint8Array
function textToUint8Array(str) {
    return new TextEncoder().encode(str);
}

// Helper: Convert Uint8Array to text
function uint8ArrayToText(arr) {
    return new TextDecoder().decode(arr);
}

// AES-GCM encryption/decryption
async function encryptAESGCM(plaintext, password) {
    const pwUtf8 = new TextEncoder().encode(password);
    const keyMaterial = await crypto.subtle.importKey('raw', pwUtf8, 'PBKDF2', false, ['deriveKey']);
    const key = await crypto.subtle.deriveKey({
        name: 'PBKDF2',
        salt: pwUtf8,
        iterations: 100000,
        hash: 'SHA-256'
    }, keyMaterial, {name: 'AES-GCM', length: 256}, true, ['encrypt']);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const enc = await crypto.subtle.encrypt({name: 'AES-GCM', iv}, key, textToUint8Array(plaintext));
    const combined = new Uint8Array(iv.byteLength + enc.byteLength);
    combined.set(iv, 0);
    combined.set(new Uint8Array(enc), iv.byteLength);
    return combined;
}

async function decryptAESGCM(ciphertext, password) {
    const pwUtf8 = new TextEncoder().encode(password);
    const keyMaterial = await crypto.subtle.importKey('raw', pwUtf8, 'PBKDF2', false, ['deriveKey']);
    const key = await crypto.subtle.deriveKey({
        name: 'PBKDF2',
        salt: pwUtf8,
        iterations: 100000,
        hash: 'SHA-256'
    }, keyMaterial, {name: 'AES-GCM', length: 256}, true, ['decrypt']);
    const iv = ciphertext.slice(0, 12);
    const data = ciphertext.slice(12);
    const dec = await crypto.subtle.decrypt({name: 'AES-GCM', iv}, key, data);
    return uint8ArrayToText(new Uint8Array(dec));
}

// Simple LSB-like steganography for demonstration
async function embedTextInImage(imgFile, text, password) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = async (e) => {
            const img = new Image();
            img.onload = async () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img,0,0);
                let data = ctx.getImageData(0,0,canvas.width,canvas.height);
                let textData = textToUint8Array(text);
                if(password) textData = await encryptAESGCM(text, password);
                // Embed each byte in LSB of pixels (very simple)
                for(let i=0;i<textData.length;i++){
                    data.data[i*4] = (data.data[i*4]&0xFE) | ((textData[i]&0x80)>>7);
                    // Can expand for full implementation
                }
                ctx.putImageData(data,0,0);
                canvas.toBlob(blob => {
                    resolve(blob);
                },'image/png');
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(imgFile);
    });
}

// Event handler
processBtn.addEventListener('click', async () => {
    const mode = modeSelect.value;
    if(!inputFile.files[0]) { alert('Select an image file'); return; }
    const text = inputText.value;
    const password = document.getElementById('password').value;
    if(mode === 'encrypt'){
        const resultBlob = await embedTextInImage(inputFile.files[0], text, password);
        outputImage.src = URL.createObjectURL(resultBlob);
        outputText.value = "Encryption successful!";
    } else {
        outputText.value = "Decryption not yet implemented";
        outputImage.src = "";
    }
});
</script>
</body>
</html>
