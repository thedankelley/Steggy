<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Steggy 1.6 ã‚¹ãƒ†ã‚®ãƒ¼</title>

<meta name="description" content="Client side steganography for deniable private communication">
<meta name="theme-color" content="#2f8f5b">

<link rel="manifest" href="manifest.json">
<link rel="icon" href="icon-192.png" sizes="192x192">
<link rel="apple-touch-icon" href="icon-192.png">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Steggy">

<script src="https://unpkg.com/openpgp@5.11.0/dist/openpgp.min.js"></script>

<script>
if ("serviceWorker" in navigator) {
  window.addEventListener("load", () => {
    navigator.serviceWorker.register("service-worker.js");
  });
}
</script>

<style>
:root {
  --bg:#f4f6f5;
  --fg:#111;
  --card:#ffffff;
  --accent:#2f8f5b;
  --warn:#c87a2b;
  --error:#b43a3a;
}

body.dark {
  --bg:#121212;
  --fg:#eaeaea;
  --card:#1f1f1f;
}

body {
  margin:0;
  font-family:system-ui,sans-serif;
  background:var(--bg);
  color:var(--fg);
}

header {
  background:var(--accent);
  color:white;
  padding:12px;
  display:flex;
  justify-content:space-between;
  align-items:center;
}

header .left {
  display:flex;
  align-items:center;
  gap:10px;
}

header img {
  width:32px;
  height:32px;
  image-rendering:pixelated;
}

main {
  max-width:980px;
  margin:auto;
  padding:16px;
}

.card {
  background:var(--card);
  padding:16px;
  border-radius:10px;
  margin-bottom:16px;
}

label {
  display:block;
  margin-top:10px;
}

input, textarea, select {
  width:100%;
  padding:8px;
  margin-top:6px;
}

textarea { resize:vertical; }

button {
  background:var(--accent);
  color:white;
  border:none;
  padding:10px;
  border-radius:6px;
  cursor:pointer;
  margin-top:12px;
}

button.secondary { background:#666; }
button.warn { background:var(--warn); }
button.error { background:var(--error); }

.hidden { display:none; }

.status {
  margin-top:10px;
  padding:10px;
  border-radius:6px;
}

.status.warn { background:#fff4e0; }
.status.error { background:#ffe0e0; }
.status.ok { background:#e5f6ec; }

footer {
  text-align:center;
  font-size:13px;
  opacity:0.85;
  padding:20px;
}
</style>
</head>

<body>
<header>
  <div class="left">
    <img src="icon-192.png">
    <strong>Steggy 1.6 ã‚¹ãƒ†ã‚®ãƒ¼</strong>
  </div>
  <button id="themeToggle">ðŸŒ™</button>
</header>

<main>

<div class="card">
  <label>Mode</label>
  <select id="mode">
    <option value="encrypt">Encrypt</option>
    <option value="decrypt">Decrypt</option>
  </select>

  <label>Carrier PNG image</label>
  <input type="file" id="imageInput" accept="image/png">

  <div id="encryptFields">
    <label>Real secret message</label>
    <textarea id="realText"></textarea>

    <label>Decoy message</label>
    <textarea id="decoyText"></textarea>

    <label>Password for real payload</label>
    <input type="password" id="password">
  </div>

  <div id="decryptFields" class="hidden">
    <button id="extractDecoy">Extract Decoy</button>
    <button id="extractReal" class="warn">Extract Protected Payload</button>
  </div>

  <div id="capacityStatus" class="status hidden"></div>

  <button class="secondary" id="advancedToggle">Advanced Settings</button>

  <div id="advanced" class="hidden">
    <label>
      <input type="checkbox" id="enablePGP">
      Enable PGP for real payload
    </label>

    <label>PGP Public Key</label>
    <textarea id="pgpPublic"></textarea>

    <label>PGP Private Key</label>
    <textarea id="pgpPrivate"></textarea>

    <button id="generatePGP" class="warn">Generate PGP Key Pair</button>
  </div>

  <button id="process">Process</button>

  <div id="statusBox" class="status hidden"></div>
</div>

<div class="card">
  <img id="preview" style="max-width:100%">
  <a id="download" class="hidden">Download image</a>
</div>

<div class="card">
  <button id="threatModelBtn" class="secondary">Threat Model</button>
  <div id="threatModel" class="hidden">
    <p>
      Steggy hides the existence of communication by embedding data inside images.
      It protects against casual inspection and automated scanning.
    </p>
    <p>
      Steggy does not protect against targeted forensic analysis by an adversary
      with prior knowledge of the tool and access to correct keys.
    </p>
  </div>
</div>

</main>

<footer>
Created by Dan<br>
Fully client side. No data leaves your device.
</footer>

<script>
/* ---------- Theme ---------- */
const themeBtn = document.getElementById("themeToggle");
if (localStorage.theme === "dark") {
  document.body.classList.add("dark");
  themeBtn.textContent = "â˜€ï¸";
}
themeBtn.onclick = () => {
  document.body.classList.toggle("dark");
  const dark = document.body.classList.contains("dark");
  localStorage.theme = dark ? "dark" : "light";
  themeBtn.textContent = dark ? "â˜€ï¸" : "ðŸŒ™";
};

/* ---------- UI ---------- */
mode.onchange = () => {
  encryptFields.classList.toggle("hidden", mode.value !== "encrypt");
  decryptFields.classList.toggle("hidden", mode.value !== "decrypt");
};
advancedToggle.onclick = () => advanced.classList.toggle("hidden");
threatModelBtn.onclick = () => threatModel.classList.toggle("hidden");

/* ---------- CRC32 ---------- */
function crc32(buf) {
  let c = ~0;
  for (let b of buf) {
    c ^= b;
    for (let i = 0; i < 8; i++) c = c & 1 ? (c >>> 1) ^ 0xedb88320 : c >>> 1;
  }
  return (~c) >>> 0;
}

/* ---------- Helpers ---------- */
function bytesToBits(bytes) {
  return bytes.flatMap(b => [7,6,5,4,3,2,1,0].map(i => (b >> i) & 1));
}

function bitsToBytes(bits) {
  const out = [];
  for (let i = 0; i < bits.length; i += 8) {
    let v = 0;
    for (let j = 0; j < 8; j++) v = (v << 1) | (bits[i + j] || 0);
    out.push(v);
  }
  return new Uint8Array(out);
}

function seededIndices(total, count, seed) {
  let s = seed || 1;
  const idx = [];
  while (idx.length < count) {
    s = (s * 9301 + 49297) % 233280;
    const r = Math.floor((s / 233280) * total);
    if (!idx.includes(r)) idx.push(r);
  }
  return idx;
}

/* ---------- AES ---------- */
async function aesEncrypt(data, pw) {
  if (!pw) return data;
  const key = await crypto.subtle.importKey(
    "raw",
    await crypto.subtle.digest("SHA-256", new TextEncoder().encode(pw)),
    "AES-GCM",
    false,
    ["encrypt"]
  );
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const enc = await crypto.subtle.encrypt({ name:"AES-GCM", iv }, key, data);
  return new Uint8Array([...iv, ...new Uint8Array(enc)]);
}

/* ---------- PGP ---------- */
generatePGP.onclick = async () => {
  const key = await openpgp.generateKey({
    type:"rsa",
    rsaBits:2048,
    userIDs:[{ name:"Steggy User" }]
  });
  pgpPublic.value = key.publicKey;
  pgpPrivate.value = key.privateKey;
};

/* ---------- Capacity ---------- */
function checkCapacity(img, bytes) {
  const capacity = Math.floor((img.width * img.height * 3) / 8 * 0.85);
  if (bytes > capacity) {
    capacityStatus.textContent = "Payload too large for this image";
    capacityStatus.className = "status error";
    capacityStatus.classList.remove("hidden");
    return false;
  }
  capacityStatus.textContent = "Capacity OK";
  capacityStatus.className = "status ok";
  capacityStatus.classList.remove("hidden");
  return true;
}

/* ---------- Main ---------- */
process.onclick = async () => {
  statusBox.classList.add("hidden");

  const file = imageInput.files[0];
  if (!file) return alert("Select image");

  const img = new Image();
  img.src = URL.createObjectURL(file);
  await img.decode();

  const canvas = document.createElement("canvas");
  canvas.width = img.width;
  canvas.height = img.height;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(img,0,0);

  const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
  const pixels = imgData.data;

  if (mode.value === "encrypt") {
    let real = new TextEncoder().encode(realText.value);
    if (enablePGP.checked && pgpPublic.value) {
      real = new TextEncoder().encode(
        await openpgp.encrypt({
          message: await openpgp.createMessage({ text: realText.value }),
          encryptionKeys: await openpgp.readKey({ armoredKey: pgpPublic.value })
        })
      );
    }
    real = await aesEncrypt(real, password.value);

    const decoy = new TextEncoder().encode(decoyText.value);
    const realCRC = crc32(real);

    const header = new Uint8Array([
      ...new TextEncoder().encode("STEGGY"),
      0x01, 0x01, 0x01,
      ...new Uint8Array(new Uint32Array([real.length]).buffer),
      ...new Uint8Array(new Uint32Array([realCRC]).buffer)
    ]);

    const fullReal = new Uint8Array([...header, ...real]);

    if (!checkCapacity(img, fullReal.length + decoy.length)) return;

    const decoyBits = bytesToBits(decoy);
    for (let i = 0; i < decoyBits.length; i++) {
      pixels[i * 4] = (pixels[i * 4] & 254) | decoyBits[i];
    }

    const realBits = bytesToBits(fullReal);
    const idx = seededIndices(pixels.length / 4, realBits.length, real.length);
    idx.forEach((p,i) => {
      pixels[p * 4] = (pixels[p * 4] & 254) | realBits[i];
    });

    ctx.putImageData(imgData,0,0);

    canvas.toBlob(b => {
      const url = URL.createObjectURL(b);
      preview.src = url;
      download.href = url;
      download.download = "steggy.png";
      download.classList.remove("hidden");
    });
  }
};
</script>
</body>
</html>
